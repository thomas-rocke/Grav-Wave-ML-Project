##################################################
##########                              ##########
##########           GAUSSIAN           ##########
##########             MODES            ##########
##########                              ##########
##################################################

# TODO Header for file

# Imports
import numpy as np
from scipy import special
from scipy.stats import truncnorm
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from tqdm import tqdm
from itertools import combinations
from multiprocessing import Pool, cpu_count




##################################################
##########                              ##########
##########           CLASSES            ##########
##########                              ##########
##################################################


class Gaussian_Mode:
    '''
    Class representing a Hermite-Gaussian mode generated by multiple Gaussian beams.
    '''

    def __init__(self, l: int = -1, m: int = -1, amplitude: float = 1.0, w_0: float = 0.4, wavelength: float = 600.0, n: int = 500):
        '''
        Initialise class.
        '''
        self.w_0 = w_0 # Waist radius
        self.z_R = (np.pi * w_0**2 * n) / wavelength # Rayleigh range
        self.k = (2 * np.pi * n) / wavelength # Wave number

        self.l = l
        self.m = m
        self.amplitude = amplitude
    
    def __str__(self):
        '''
        Magic method for str() function.
        '''
        return self.__class__.__name__ + "(" + str(self.l) + ", " + str(self.m) + ", " + str(self.amplitude) + ")"
    
    def __repr__(self):
        '''
        Magic method for repr() function.
        '''
        return str(self)

    def E(self, r, z):
        '''
        Electric field at a given radial distance and axial distance.
        '''
        w_ratio = self.w_0 / self.w(z)
        exp_1 = np.exp(-(r**2) / self.w(z)**2)
        exp_2 = np.exp(-1j * (self.k * z + self.k * (r**2 / (2 * self.R(z))) - self.phi(z)))

        return self.amplitude * (w_ratio * exp_1 * exp_2)
    
    def E_mode(self, x, y, z):
        '''
        Electric field amplitude at x, y, z for a given mode of order l, m.
        '''
        return self.amplitude * (self.u(x, z, self.l) * self.u(y, z, self.m) * np.exp(-1j * self.k * z))
    
    def w(self, z):
        '''
        Spot size parameter is given by a hyperbolic relation.
        '''
        return self.w_0 * np.sqrt(1 + (z / self.z_R)**2)
    
    def R(self, z):
        '''
        Radius of curvature.
        '''
        return z * (1 + (self.z_R / z)**2)
    
    def phi(self, z):
        '''
        Gouy phase is a phase advance gradually aquired by a beam around the focal region.
        '''
        return np.arctan(z / self.z_R)
    
    def P(self, r, z):
        '''
        Power passing through a circle of radius r in the tarnsverse plane at position z.
        '''
        return 1 - np.exp((-2 * r**2) / self.w(z)**2)
    
    def q(self, z):
        '''
        Complex beam parameter.
        '''
        return z + self.z_R * 1j
    
    def u(self, x, z, J):
        '''
        Factors for the x and y dependance.
        '''
        q0 = self.q(0) # ???
        
        t1 = np.sqrt(np.sqrt(2 / np.pi) / (2**J * np.math.factorial(J) * self.w_0))
        t2 = np.sqrt(q0 / self.q(z))
        t3 = (-np.conj(self.q(z)) / self.q(z))**(J / 2)
        t4 = (np.sqrt(2) * x) / self.w(z)
        t5 = np.exp(-1j * ((self.k * x**2) / (2 * self.q(z))))

        return t1 * t2 * t3 * special.eval_hermite(J, t4) * t5
    
    def plot(self, title: bool = True):
        '''
        Plot the Gaussian mode.
        '''
        X, Y = np.meshgrid(np.arange(-1.2, 1.2, 0.01), np.arange(-1.2, 1.2, 0.01))
        plt.figure(self.__class__.__name__)

        plt.imshow(np.abs(np.abs(self.E_mode(X, Y, 0))), cmap='Greys_r')

        if title: plt.title(str(self))
        plt.axis('off')
    
    def show(self, title: bool = True):
        '''
        Show the plot of the Gaussian mode.
        '''
        self.plot(title)
        plt.show()
    
    def save(self, title: bool = True):
        '''
        Save the plot of the Gaussian mode.
        '''
        self.plot(title)
        plt.savefig("Images/" + str(self) + ".png", bbox_inches='tight', pad_inches=0)




class Superposition(list):
    '''
    Class repreenting a superposition of multiple Gaussian modes.
    '''

    def __init__(self, modes: list, amplitude_variation: float = 0):
        '''
        Initialise the class with the list of modes that compose the superposition.
        '''
        self.modes = [eval(str(mode)) for mode in modes] # Create duplicate of Gaussian modes for random normalised ampltidues
        super().__init__(self.modes)

        random_amplitudes = [self.random_amplitude(amplitude_variation) for i in range(len(self))] # Generate random amplitudes
        random_normalised_amplitudes = random_amplitudes / np.linalg.norm(random_amplitudes) # Normalise the amplititudes

        for i in range(len(self)): self[i].amplitude = random_normalised_amplitudes[i] # Set the normalised amplitude variations to the modes

        X, Y = np.meshgrid(np.arange(-1.2, 1.2, 0.01), np.arange(-1.2, 1.2, 0.01))
        superposition = np.abs(sum([i.E_mode(X, Y, 0) for i in self])) # Computae the superposition of the Gaussian modes

        self.superposition = superposition / np.linalg.norm(superposition) # Normalise the superposition
    
    def __str__(self):
        '''
        Magic method for str() function.
        '''
        return self.__class__.__name__ + "(" + str(self.modes) + ")"
    
    def __repr__(self):
        '''
        Magic method for repr() function.
        '''
        return str(self)
    
    def random_amplitude(self, amplitude_variation):
        '''
        Get random value for the amplitude based on amplitude variation as the width of a normal distribution.
        '''
        return abs(round(np.random.normal(scale=amplitude_variation), 2) + 1)
        # x = 0
        # while x <= 0: x = round(np.random.normal(1, amplitude_variation), 2)
        # return x
    
    # def get_truncated_normal(self, mean=1, sd=1, low=0, upp=10):
    #     '''
    #     Get truncated normal in a format that is easier to interpret.
    #     '''
    #     return truncnorm((low - mean) / sd, (upp - mean) / sd, loc=mean, scale=sd)

    def plot(self, title: bool = True):
        '''
        Plot the superposition.
        '''
        # for i in self: i.plot() # Plot the constituent Gaussian modes
        plt.figure(self.__class__.__name__)

        plt.imshow(self.superposition, cmap='Greys_r')

        if title: plt.title(str(self))
        plt.axis('off')
    
    def show(self, title: bool = True):
        '''
        Show the plot of the Gaussian mode.
        '''
        self.plot(title)
        plt.show()
    
    def save(self, title: bool = True):
        '''
        Save the plot of the Gaussian mode.
        '''
        self.plot(title)
        plt.savefig("Images/" + str(self) + ".png", bbox_inches='tight', pad_inches=0)




class Generate_Data(list):
    '''
    Class representing many superpositions of multiple Guassian modes at a specified complexity.
    '''
    
    def __init__(self, max_order: int = 1, number_of_modes: int = 1, amplitude_variation: float = 0):
        '''
        Initialise the class with the required complexity.

        'max_order': Max order of Guassian modes in superpositions (x > 0).
        'number_of_modes': How many modes you want to superimpose together (x > 0).
        'ampltude_variation': How much you want to vary the amplitude of the Gaussian modes by (x > 0).
        '''
        self.max_order = max_order
        self.number_of_modes = number_of_modes
        self.amplitude_variation = amplitude_variation

        print("\n-----| Generating Data |-----\n")
        print("Max order of mode: " + str(max_order) + "\nNumber of modes in superposition: " + str(number_of_modes) + "\nVariation in mode amplitude: " + str(amplitude_variation) + "\n")
        print("Generating Gaussian modes...")

        gauss_modes = [Gaussian_Mode(l=i, m=j) for i in tqdm(range(max_order)) for j in range(max_order)]

        print("Done! Found " + str(len(gauss_modes)) + " modes.\n\nGenerating superpositions...")

        self.combs = list(combinations(gauss_modes, number_of_modes))
        
        # self.pool_handler(self.combs, 5)
        # p = Pool(5)
        # p.map(self.process, self.combs)

        super().__init__()
        for i in tqdm(range(len(self.combs))): self.append(Superposition(self.combs[i], amplitude_variation))

        print("Done! Found " + str(len(self)) + " combinations.\n")
    
    def get_outputs(self):
        '''
        Get all possible Gaussian modes that could comprise a superposition.
        '''
        return self.combs, np.array([[i] for i in range(len(self.combs))])
    
    # def pool_handler(self, data, threads):
    #     '''

    #     '''
    #     p = Pool(threads)
    #     p.map(self.process, data)
    
    # def process(self, data):
    #     '''
        
    #     '''
    #     # print(self.combs.index(data), data)
    #     data[0].append(Superposition(data[1], self.amplitude_variation))
    
    # def __str__(self):
    #     '''
    #     Magic method for str() function.
    #     '''
    #     return self.__class__.__name__ + "(" + [self.__getitem__(i) for i in range(len(self))] + ")"
    
    # def __repr__(self):
    #     '''
    #     Magic method for repr() function.
    #     '''
    #     return self.__class__.__name__ + "(" + str(self.max_order) + ", " + str(self.number_of_modes) + ", " + str(self.amplitude_variation) + ")"
    
    def plot(self):
        '''
        Plot all superpositions generated.
        '''
        for i in self: i.plot()




##################################################
##########                              ##########
##########            MAIN              ##########
##########                              ##########
##################################################



# def process(x):
#     print("Process started for '" + x[0] + "' for k = " + str(x[1]) + " for event " + str(x[2]) + "...")
#     fh.write_data(x[0], x[2], x[1])

# def pool_handler(x, t):
#     p = Pool(t)
#     p.map(process, x)

# if __name__ == '__main__':
#     d = input("File: ")
#     k = input("k: ")
#     t = input("Threads: ")

#     x = [(str(d), int(k), int(e)) for e in range(9999)]
#     pool_handler(x, int(t))


# def generate_modes(ls, ms):
#     '''
#     Generate and save modes from (0,0) to (ls,ms).
#     '''
#     for l in range(ls):
#         for m in tqdm(range(ms)):
#             X, Y = np.meshgrid(np.arange(-1.2, 1.2, 0.01), np.arange(-1.2, 1.2, 0.01))
            
#             mode = Gaussian_Mode(0.4, 600, 500, l, m)

#             plt.imshow(np.abs(mode.E_mode(X, Y, 0)), cmap='Greys_r')
#             plt.axis('off')
#             plt.savefig("Images/" + str(l) + str(m) + ".png", bbox_inches='tight', pad_inches=0)





##################################################
##########                              ##########
##########           TESTING            ##########
##########                              ##########
##################################################



# x1 = Gaussian_Mode(0,1)
# x2 = Gaussian_Mode(1,0)
# x = Superposition([x1,x2])
# x[0].amplitude = 1/np.sqrt(2)
# x[1].amplitude = 1j/np.sqrt(2)
# print(x)
# x.show()

if __name__ == '__main__':
    x = Generate_Data(5, 3)
    x.plot()




# x = np.arange(-1.2, 1.2, 0.01)
# y = np.arange(-1.2, 1.2, 0.01)

# X, Y = np.meshgrid(x, y)

# fig, ax = plt.subplots()

# Testing a superposition of 3 basic modes.

# mode = Gaussian_Mode(0.4, 600, 500)

# plt.imshow(np.abs(mode.E2(X, Y, 0, 1, 0) + mode.E2(X, Y, 0, 2, 2) + mode.E2(X, Y, 0, 4, 1)), cmap='Greys_r')
# plt.axis('off')
# plt.savefig("Images/superposition.png", bbox_inches='tight', pad_inches=0)

# Generating and saving all mode combinations from (0,0) to (5,5).

# generate_modes(5, 5)




# TODO Animate Hermite-Gaussian modes as a GIF

# data = []
# for i in tqdm(range(1, 500)):
#     mode = Gaussian_Mode(0.4, 600, i)
#     data.append(mode.E(X, Y))

# def update(data):
#     mat.set_data(data)
#     return mat

# def animate():
#     for i in data: yield i # Animate the states of the game

# mat = ax.imshow(np.real(mode.E(X, Y)))
# anim = animation.FuncAnimation(fig, update, animate, interval=100, save_count=50) # Create the animation for state evolutio using Markov Chain